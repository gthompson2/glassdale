import { useCriminals, getCriminals } from './CriminalProvider.js';
import { Criminal } from './Criminal.js';
import { useConvictions } from '../convictions/ConvictionProvider.js'; // useConvictions isn't used by this file until ConvictionSelect pulls the data

const eventHub = document.querySelector(".container") // listen for and make noise on container class element --> <main>
const criminalElement = document.querySelector(".criminalsContainer"); // listen for and make noise on  criminalsContainer element --> <article>
                                                                        // criminalsContainer populates the body with the criminal data

// render is in charge of generating HTML and populating the DOM
const render = (criminals) => {
    let criminalCards = []
    // generate HTML based on criminals array, imported from useCriminals()
    // store HTML in criminalCards array
    for (const perp of criminals) {
        criminalCards.push(Criminal(perp))
    }
    // add criminalCards elements to the DOM at criminalElement --> <article class="criminalsContainer">
    criminalElement.innerHTML = criminalCards.join(" ")
}

//Listen for the custom event that was dispatched in ConvictionSelect
//useConvictions isn't used by CriminalList.js until ConvictionSelect.js uses getConvictions
eventHub.addEventListener('crimeChosen', event => {
    // Use the property that was added to event detail
    if (event.detail.crimeThatWasChosen !== "0") {
        /*
            Filter the criminals application state down to the people
            that committed the crime
        */
       //ConvictionSelect called getConvictions, so useConvictions now has data to provide
       // import the aray of crime objects
       const crimes = useConvictions() 
       // find the first object in the array whose Object.id value matches the 
       // custom event's event.detail.value, which was generated by 
       // ConvictionSelect's render() function --> <option value="[someNum]">
       const crime = crimes.find(crime => crime.id === parseInt(event.detail.crimeThatWasChosen))

       // imports the array of criminal objects
       const criminals = useCriminals()
       // fill a new array with only the criminals objects whose conviction value
       // matches with the crime that corresponds to event.detail.crimeThatWasChosen --> <option value="[someNum]">
       const matchingCriminals = criminals.filter((criminal) => {
           return criminal.conviction === crime.name
       })
       // send array of filtered criminals to render() to populate the DOM
       render(matchingCriminals)

       
    }
}
)


// this is the only function that needs to be exported and called,
// since everything else is event-driven
export const CriminalList = () => {
    /**
     * getCriminals() has to finish fetching and parsing data 
     * before you can use said data, or import the array from useCriminals().
     * We need another .then() to make sure that the program waits until
     * getCriminals() is done. 
     * 
     * We can use .then on getCriminals() because getCriminals returns
     * the results of calling fetch(). fetch() returns a promised object,
     * and by extension, getCriminals() does the same.
     */
    getCriminals().then(() => {
        let perp = useCriminals()
        render(perp)

    })
}