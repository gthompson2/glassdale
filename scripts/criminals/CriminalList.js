import { useCriminals, getCriminals } from './CriminalProvider.js';
import { Criminal } from './Criminal.js';
import { useConvictions } from '../convictions/ConvictionProvider.js'; // useConvictions isn't used by this file until ConvictionSelect pulls the data
import { getOfficers, useOfficer } from '../officers/OfficerProvider.js';
import { getFacilities, useFacilities } from '../facility/facilityProvider.js';
import { getCriminalFacilities, useCriminalFacilities } from '../facility/criminalFacilityProvider.js';

const eventHub = document.querySelector(".container") // listen for and make noise on container class element --> <main>
const criminalElement = document.querySelector(".criminalsContainer"); // listen for and make noise on  criminalsContainer element --> <article>
                                                                        // criminalsContainer populates the body with the criminal data

// render is in charge of generating HTML and populating the DOM
const render = (criminals, allFacilities, allRelationships) => {
    // Step 1: Iterate all criminals
    criminalElement.innerHTML = criminals.map(
        (criminalObj) => {
            // Step 2: Filter all relationships to get only ones for this criminal
            const facilityRelationshipsForThisCriminal = allRelationships.filter(cf => cf.criminalId === criminalObj.id)

            // Step 3: Convert the relationships to facilities with .map()
            const facilities = facilityRelationshipsForThisCriminal.map(cf => {
                const matchingFacilityObj = allFacilities.find(facility => facility.id === cf.facilityId)
                return matchingFacilityObj
            })

            return Criminal(criminalObj, facilities)
        }
    ).join("")
}

//Listen for the custom event that was dispatched in ConvictionSelect
//useConvictions isn't used by CriminalList.js until ConvictionSelect.js uses getConvictions

// NEEDS TO BE REFACTORED NOW THAT RENDER IS BEING CHANGED
eventHub.addEventListener('crimeChosen', event => {
    // Use the property that was added to event detail
    if (event.detail.crimeThatWasChosen !== "0") {
        /*
            Filter the criminals application state down to the people
            that committed the crime
        */
       //ConvictionSelect called getConvictions, so useConvictions now has data to provide
       // import the aray of crime objects
       const crimes = useConvictions() 
       // find the first object in the array whose Object.id value matches the 
       // custom event's event.detail.value, which was generated by 
       // ConvictionSelect's render() function --> <option value="[someNum]">
       const crime = crimes.find(crime => crime.id === parseInt(event.detail.crimeThatWasChosen))

       // imports the array of criminal objects
       const criminals = useCriminals()
       // fill a new array with only the criminals objects whose conviction value
       // matches with the crime that corresponds to event.detail.crimeThatWasChosen --> <option value="[someNum]">
       const matchingCriminals = criminals.filter((criminal) => {
           return criminal.conviction === crime.name
       })
       // send array of filtered criminals to render() to populate the DOM
       render(matchingCriminals)

       
    }
})
// NEEDS TO BE REFACTORED NOW THAT RENDER IS BEING CHANGED
eventHub.addEventListener('officerChosen', event => {
    if (event.detail.officerThatWasChosen !== "0"){
        const officers = useOfficer()
        // officer now holds the correct officer object after 
        // identifying the object by id, 
        // which corresponds with the correct option element's value
        const officer = officers.find(officer => officer.id === parseInt(event.detail.officerThatWasChosen))
        const criminals = useCriminals()
        const matchingCriminals = criminals.filter((criminal) => {
            return criminal.arrestingOfficer === officer.name
        })
        render(matchingCriminals)
    }
})



// this is the only function that needs to be exported and called,
// since everything else is event-driven
export const CriminalList = () => {
    /**
     * getCriminals() has to finish fetching and parsing data 
     * before you can use said data, or import the array from useCriminals().
     * We need another .then() to make sure that the program waits until
     * getCriminals() is done. 
     * 
     * We can use .then on getCriminals() because getCriminals returns
     * the results of calling fetch(). fetch() returns a promised object,
     * and by extension, getCriminals() does the same.
     */
    getCriminals()
    // once we get criminal data, get data representing
    // facilities and the criminal-facility relationship
        .then(getFacilities)
        .then(getCriminalFacilities)
        .then(() => {
            //pull in the data now that it has been fetched
            const facilities = useFacilities()
            const crimFac = useCriminalFacilities()
            const criminals = useCriminals()

                render(criminals, facilities, crimFac)
        })
        
    
}